{
  "name": "falafel-map",
  "description": "transform the ast on a recursive walk, generating a source map",
  "version": "0.3.2",
  "repository": {
    "type": "git",
    "url": "git://github.com/alltom/node-falafel-map.git"
  },
  "main": "index.js",
  "keywords": [
    "ast",
    "source",
    "traversal",
    "syntax",
    "tree",
    "burrito"
  ],
  "directories": {
    "example": "example",
    "test": "test"
  },
  "scripts": {
    "test": "tape test/*.js"
  },
  "dependencies": {
    "source-map": "0.1.x"
  },
  "devDependencies": {
    "tape": "~1.0.4"
  },
  "engines": {
    "node": ">=0.4.0"
  },
  "license": "MIT",
  "author": {
    "name": "James Halliday",
    "email": "mail@substack.net",
    "url": "http://substack.net"
  },
  "contributors": [
    {
      "name": "Tom Lieber",
      "email": "tom@alltom.com",
      "url": "http://alltom.com/"
    }
  ],
  "testling": {
    "files": "test/*.js",
    "browsers": {
      "iexplore": [
        "6.0",
        "7.0",
        "8.0",
        "9.0"
      ],
      "chrome": [
        "20.0"
      ],
      "firefox": [
        "10.0",
        "15.0"
      ],
      "safari": [
        "5.1"
      ],
      "opera": [
        "12.0"
      ]
    }
  },
  "readme": "# falafel-map\n\nTransform the [ast](http://en.wikipedia.org/wiki/Abstract_syntax_tree) on a\nrecursive walk.\n\nThis module is like [falafel](https://github.com/substack/node-falafel),\nexcept that it uses [source-map](https://github.com/mozilla/source-map) for\nappending source maps to processed scripts.\n\n![falafel d√∂ner](http://substack.net/images/falafel.png)\n\n# example\n\n## array.js\n\nPut a function wrapper around all array literals.\n\n``` js\nvar falafelMap = require('falafel-map');\n\nvar src = '(' + function () {\n    var xs = [ 1, 2, [ 3, 4 ] ];\n    var ys = [ 5, 6 ];\n    console.dir([ xs, ys ]);\n} + ')()';\n\nvar output = falafelMap(src, function (node) {\n    if (node.type === 'ArrayExpression') {\n        node.update('fn(' + node.source() + ')');\n    }\n});\nconsole.log(output);\n```\n\noutput:\n\n```\n(function () {\n    var xs = fn([ 1, 2, fn([ 3, 4 ]) ]);\n    var ys = fn([ 5, 6 ]);\n    console.dir(fn([ xs, ys ]));\n})()\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3V0LmpzIiwic291cmNlcyI6WyJpbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxDQUFDLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFZLENBQUE7QUFBQSxDQUFBLENBQUEsQ0FBQSxDQUNULENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLDBCQUFULENBRFM7QUFBQSxDQUFBLENBQUEsQ0FBQSxDQUVULENBQUEsQ0FBQSxDQUFBLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFLLFlBQVQsQ0FGUztBQUFBLENBQUEsQ0FBQSxDQUFBLENBR1QsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFRLENBQUEsQ0FBQSxDQUFSLENBQVksY0FBWixDQUFBLENBSFM7QUFBQSxDQUFiLENBQUEsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHhzID0gWyAxLCAyLCBbIDMsIDQgXSBdO1xuICAgIHZhciB5cyA9IFsgNSwgNiBdO1xuICAgIGNvbnNvbGUuZGlyKFsgeHMsIHlzIF0pO1xufSkoKSJdfQ==\n```\n\n## custom keyword\n\nCreating custom keywords is super simple!\n\nThis example creates a new `beep` keyword that uppercases its arguments:\n\n``` js\nvar falafelMap = require('falafel-map');\nvar src = 'console.log(beep \"boop\", \"BOOP\");';\n\nfunction isKeyword (id) {\n    if (id === 'beep') return true;\n}\n\nvar output = falafelMap(src, { isKeyword: isKeyword }, function (node) {\n    if (node.type === 'UnaryExpression'\n    && node.keyword === 'beep') {\n        node.update(\n            'String(' + node.argument.source() + ').toUpperCase()'\n        );\n    }\n});\nconsole.log(output);\n```\n\nNow the source string `console.log(beep \"boop\", \"BOOP\");` is converted to:\n\n```\n$ node example/keyword.js\nconsole.log(String(\"boop\").toUpperCase(), \"BOOP\");\n//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3V0LmpzIiwic291cmNlcyI6WyJpbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQVEsQ0FBQSxDQUFBLENBQVIsQ0FBWSw0QkFBWixDQUFBLENBQXlCLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUF6QixDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiY29uc29sZS5sb2coYmVlcCBcImJvb3BcIiwgXCJCT09QXCIpOyJdfQ==\n```\n\nwhich we can execute:\n\n```\n$ node example/keyword.js | node\nBOOP BOOP\n```\n\nNeat!\n\n# methods\n\n``` js\nvar falafelMap = require('falafel-map')\n```\n\n## falafelMap(src, opts={}, fn)\n\nTransform the string source `src` with the function `fn`, returning a\nstring-like transformed output object.\n\nFor every node in the ast, `fn(node)` fires. The recursive walk is a\npre-traversal, so children get called before their parents.\n\nPerforming a pre-traversal makes it easier to write nested transforms since\ntransforming parents often requires transforming all its children first.\n\nThe return value is string-like (it defines `.toString()` and `.inspect()`) so\nthat you can call `node.update()` asynchronously after the function has\nreturned and still capture the output.\n\nInstead of passing a `src` you can also use `opts.source`.\n\nAll of the `opts` will be passed directly to esprima except for `'range'` and\n`'loc'`, which are always turned on because falafel-map needs them.\n\n`'sourceFilename'` and `'generatedFilename'` can be used to control the names\nused in the map, and default to `in.js` and `out.js`, respectively.\n\nSome of the options you might want from esprima includes:\n`'loc'`, `'raw'`, `'comment'`, `'tokens'`, and `'tolerant'`.\n\nfalafel uses a custom patch of esprima with support for an `opts.isKeyword()`\nfunction. When `opts.isKeyword(id)` returns `true`, the string `id` will be\ntreated as a keyword. You can use this behavior to create custom unary\nexpression keywords.\n\nAn `opts.isKeyword(id)` value that is a string will be mapped to existing types.\nThe only currently supported string value is `\"block\"`.\n\n# nodes\n\nAside from the regular [esprima](http://esprima.org) data, you can also call\nsome inserted methods on nodes.\n\nAside from updating the current node, you can also reach into sub-nodes to call\nupdate functions on children from parent nodes.\n\n## node.source()\n\nReturn the source for the given node, including any modifications made to\nchildren nodes.\n\n## node.sourceNodes()\n\nReturn the array of strings and SourceNodes for the given esprima node.\n\n## node.update()\n\nReplace the source nodes for the given node with the arguments to `update`,\nbe they strings or SourceNodes.\n\nTo maintain source mappings to children, pass the result of `node.sourceNodes()`\nas one of the arguments to this function. For example:\n`node.update(\"[\", node.sourceNodes(), \"]\")`.\n\nNote that in `'ForStatement'` node types, there is an existing subnode called\n`update`. For those nodes all the properties are copied over onto the\n`node.update()` function.\n\n## node.parent\n\nReference to the parent element or `null` at the root element.\n\n# install\n\nWith [npm](http://npmjs.org) do:\n\n```\nnpm install falafel-map\n```\n\n# license\n\nMIT\n\n",
  "readmeFilename": "readme.markdown",
  "bugs": {
    "url": "https://github.com/alltom/node-falafel-map/issues"
  },
  "homepage": "https://github.com/alltom/node-falafel-map",
  "bundleDependencies": [
    "esprima"
  ],
  "_id": "falafel-map@0.3.2",
  "dist": {
    "shasum": "d81643c4b64e3b67ca0216bbf5430aef1c32ab71"
  },
  "_from": "falafel-map@0.3.2",
  "_resolved": "https://registry.npmjs.org/falafel-map/-/falafel-map-0.3.2.tgz"
}
